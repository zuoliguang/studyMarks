
==============================================================================================================================

1.函数内部 static 和 global 关键字的作用
    static 是静态变量,在局部函数中存在且只初始化一次,使用过后再次使用会使用上次执行的结果; 作为计数，程序内部缓存，单例模式中都有用到。
    global 关键字,引用全局变量，wordpress中大量用到，如面向过程开发。
    static 静态方法,是类的成员方法,但不需要实例化类可直接使用
    $GLOBAL 在函数内使用具有全局作用域的变量,如$GLOBAL[‘a’]

2.子类重写父类的 protected 方法有什么限制？或者说有什么要遵守的规则？
    用例子说明，以 Laravel 框架中的控制器作为说明
    ①final修饰的类方法不可被子类重写
    ②PHP是否重写父类方法只会根据方法名是否一致判断（5.3以后重写父类方法参数个数必须一致）
    ③重写时访问级别只可以等于或者宽松于父类 不可提升访问级别

3.PHP文件末尾是否应该加 ?> 结束符号，为什么？
    主要防止 include，require 引用文件，把文件末尾可能的回车和空格等字符引用进来，还有一些函数必须在没有任何输出之前调用，就会造成不是期望的结果。
    PHP文件的编码不包含BOM的UTF8. 这也是PSR-2中的规范：纯PHP代码文件必须省略最后的 ?> 结束标签。

4.谈一谈 PHP 开源框架 CI，ThinkPHP，Laravel 的优缺点及选型依据
    CI非常轻量级，是一个简单的MVC框架，性能也很快。
    ThinkPHP3.2国内使用比较多，优点是文档非常多，各种问题解决方案比较多，缺点是代码不够规范，理念落后。
    Laravel 是一个现代化的PHP开发框架，代码优雅，使用 composer 方式扩展功能，社区活跃，缺点是比较重，比较适合做后台管理或者应用型WEB系统。

5.Memcache 和 Redis 的读写性能（qps）如何？两者优缺点？Redis 支持哪些数据类型？Redis 如何持久化？
    读写性能：
    memcache更加快速，在读取性能上比 Redis 快，缺点是仅支持字符串。
    Redis支持丰富的数据结构类型，字符串，散列（哈希），集合，有序集合，还支持订阅发布，地理位置等等。
    实际运用中可以redis，memcache结合，memcache可作为session存储的方式，session都是KV类型键值对。
    Redis 提供了多种不同级别的持久化方式：
    RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。
    AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 
    协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出
    保存数据集状态所需的实际大小。
    Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 
    文件保存的数据集通常比 RDB 文件所保存的数据集更完整。
    你甚至可以关闭持久化功能，让数据只在服务器运行时存在。
    参见：http://doc.redisfans.com/topic/persistence.html

6.使用 PHP 下载网络图片，有哪些方法？
    1.file_get_contents
    2.readfile读取内容
    3.fopen系列函数
    4.curl

7.什么是 CGI？什么是 FastCGI？php-fpm，FastCGI，Nginx 之间是什么关系？
        CGI，通用网关接口，用于WEB服务器和应用程序间的交互，定义输入输出规范，用户的请求通过WEB服务器转发给FastCGI进程，
    FastCGI进程再调用应用程序进行处理，如php解析器，应用程序的处理结果如html返回给FastCGI，FastCGI返回给Nginx 进行输出。
    假设这里WEB服务器是Nginx，应用程序是 PHP，而 php-fpm 是管理 FastCGI 的，这也就是 php-fpm，FastCGI，和 Nginx 之间的关系。
        FastCGI 用来提高 cgi 程序性能，启动一个master，再启动多个 worker，不需要每次解析 php.ini. 而 php-fpm 实现了 FastCGI 协议，
    是 FastCGI 的进程管理器，支持平滑重启，可以启动的时候预先生成多个进程。

8.什么是 CSRF 攻击 ？XSS 攻击？如何防范？
    CSRF，跨站请求伪造，攻击方伪装用户身份发送请求从而窃取信息或者破坏系统。
    讲述基本原理：用户访问A网站登陆并生成了cookie，再访问B网站，如果A网站存在CSRF漏洞，此时B网站给A网站的请求（此时相当于是用户访问），
    A网站会认为是用户发的请求，从而B网站就成功伪装了你的身份，因此叫跨站脚本攻击。
    CSRF防范：
    1.合理规范api请求方式，GET，POST
    2.对POST请求加token令牌验证，生成一个随机码并存入session，表单中带上这个随机码，提交的时候服务端进行验证随机码是否相同。
    XSS，跨站脚本攻击。
    防范：不相信任何输入，过滤输入。

9.写一段代码，实现PHP内部的通知机制，如当一个类的属性发生变化时，另外一个类就可以收到通知。
    观察者模式的应用，使用代码示例说明。
    对象的一种一对多的关系，当依赖的对象状态发生改变时，所有依赖它的对象都得到通知并被自动更新。
    观察者模式又称发布订阅模式。
    1.抽象主体（Subject）角色：主体角色将所有对观察者对象的引用保存在一个集合中，每个主体可以有任意多个观察者。 抽象主体提供了增加和
        删除观察者对象的接口。主体也就是被观察者。
    2.抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在观察的主体发生改变时更新自己。
    3.具体主体（ConcreteSubject）角色：存储相关状态到具体观察者对象，当具体主体的内部状态改变时，给所有登记过的观察者发出通知。
        具体主体角色通常用一个具体子类实现。
    4.具体观察者（ConcretedObserver）角色：存储一个具体主体对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和
        主题的状态保持一致。

===================================================================================================================================

1. php的垃圾回收机制PHP可以自动进行内存管理，清除不需要的对象。
    PHP使用了引用计数(reference counting) GC机制。每个对象都内含一个引用计数器refcount，每个reference连接到对象，计数器加1。
    当reference离开生存空间或被设为NULL，计数器减1。当某个对象的引用计数器为零时，PHP知道你将不再需要使用这个对象，释放其所占的内存空间。
    参考 http://www.php.net/manual/zh/features.gc.refcounting-basics.php

2. session与cookie的区别和联系区别：
    1.存放位置：Session保存在服务器，Cookie保存在客户端。
    2.存放的形式：Session是以对象的形式保存在服务器，Cookie以字符串的形式保存在客户端。
    3.用途：Cookies适合做保存用户的个人设置,爱好等,Session适合做客户的身份验证
    4.路径：Session不能区分路径，同一个用户在访问一个网站期间，所有的Session在任何一个地方都可以访问到。
        而Cookie中如果设置了路径参数，那么同一个网站中不同路径下的Cookie互相是访问不到的。
    5.安全性：Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session
    6.大小以及数量限制:
        每个域名所煲含的cookie 数:IE7/8,FireFox:50个, Opera30个； 
        Cookie总大小：Firefox和Safari允许cookie多达4097个字节，Opera允许cookie多达4096个字 节，InternetExplorer允许cookie多达4095个字节；
        一般认为Session没有大小和数量限制。
        联系：
            1. Session需要借助Cookie才能正常工作。如果客户端完全禁止Cookie，Session将失效。
                因为Session是由应用服务器维持的一个 服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 
                为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，
                会将这一 SessionID 提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，
                那么Session也会失效。
                
3. 如何修改SESSION的生存时间
    1. 设置浏览器保存的sessionid失效时间 setcookie(session_name(), session_id(), time() + $lifeTime, "/");
    2. 可以使用SESSION 自带的 session_set_cookie_params(86400); 来设置 Session 的生存期
    3. 通过修改php.ini中的session.gc_maxlifetime参数的值就可以改变session的生存时间
    
4. PHP页面重定向的方法有哪些
    1. header('Location: http://www.baidu.com/') ;
    2. echo '<script>window.location.href="http://www.baidu.com/"</script>';
    
5. PDO、adoDB、PHPLib数据库抽象层比较PHP数据库抽象层就是指，封装了数据库底层操作的介于PHP逻辑程序代码和数据库之间的中间件。
    PDO以PHP 5.1为基础进行设计，它使用C语言做底层开发，设计沿承PHP的特点，以简洁易用为准，从严格意义上讲，PDO应该归为PHP 5的SPL库之一，
    而不应该归于数据抽象层，因为其本身和MySQL和MySQLi扩展库的功能类似。
    PDO是不适合用在打算或者有可能会变更数据库的系 统中的。ADODB不管后端数据库如何，存取数据库的方式都是一致的；转移数据库平台时，
    程序代码也不必做太大的更动，事实上只需要改动数据库配置文 件。
    提供了大量的拼装方法，目的就是针对不同的数据库在抽象层的底层对这些语句进行针对性的翻译，以适应不同的数据库方言。
    但是这个抽象层似乎体积过于庞 大了，全部文件大概有500K左右，如果你做一个很小的网站的话，用这个似乎大材小用了PHPLib可能是伴随PHP一同成长
    最老的数据库抽象层（但和ADODB相比，它只算是一个MySQL抽象类库），这个抽象类使用方法相当简单，体积小，是小型网站开发不错的选择。
    PDO提供预处理语句查询、错误异常处理、灵活取得查询结果（返回数组、字符串、对象、回调函数）、字符过滤防止SQL攻击、事务处理、存储过程。
    ADODB支持 缓存查询、移动记录集、（HTML、分页、选择菜单生成）、事务处理、输出到文件。 
    参考 http://apps.hi.baidu.com/share/detail/463678
    
6. 长连接、短连接的区别和使用长连接：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。
    此种方式常用于P2P通信。短连接：Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。
    C/S通信。长连接与短连接的使用时机：长连接：短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个TCP连 接的建立都需要三次握手，
    每个TCP连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立
    TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，频繁的socket创建也是对资源的浪 费。短连接：web网站的http服务
    一般都用短连接。因为长连接对于服务器来说要耗费一定 的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用
    长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需
    要短连接。参考http://www.cnblogs.com/Roberts/archive/2010/12/05/1986550.html
    
7. HTTP协议详解、应用http（超文本传输协议）是一个基于请求与响应模式的、无状态的、短连接、灵活、应用层的协议，常基于TCP 的连接方式。
    参考 http://blog.csdn.net/gueter/article/details/1524447 (http协议详解)(HTTP响应状态码)HTTP响应状态码状态代码有三位数字组成，第一个
    数字定义了响应的类别，且有五种可能取值：1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要
    完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求常见状态代码、状态描
    述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代
    码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的
    URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器超时 //可能恢复正常304 Not Modifed //自从上次请
    求后，请求的网页未修改过。//服务器返回此响应时，不会返回网页内容。
    
8. 异构系统通讯中的通讯加密方案参考 http://blog.csdn.net/linvo/article/details/5741942

9. socket连接步骤Socket（套接字）概念套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，
    煲含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。Socket连接过程建立
    Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket套接字之间的连接过程可以分为三个
    步骤：服务器监听，客户端请求，连接确认。服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。客户端
    请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套
    接字的地址和端口号，然后就向服务器端套接字提出连接请求。连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套
    接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接
    收其他客户端套接字的连接请求。

10. TCP协议，三次握手、四次挥手TCP协议(Transmission Control Protocol)是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一
    个连接，四次挥手断开连接。位码即tcp标志位,有6种标示:SYN(synchronous建立联机) 同步ACK(acknowledgement 确认)
    PSH(push传送)FIN(finish结束)RST(reset重置)URG(urgent紧急)

11. php中常用作用相似，性能差异很大的函数区分及举例参考 http://apps.hi.baidu.com/share/detail/43169774

12. posix及perl兼容正则比较，及函数性能分析POSIX正则和 PCRE正则最显著的需要知道的不同点：1. PCRE函数需要模式以分隔符闭合.2. POSIX兼容正则没
    有修正符。不像POSIX, PCRE扩展没有专门用于大小写不敏感匹配的函数. 取而代之的是, 支持使用/i 模式修饰符完成同样的工作. 其他模式修饰符同样可用于
    改变匹配策略.3. POSIX函数从最左面开始寻找最长的匹配, 但是PCRE在第一个合法匹配后停止. 如果字符串 不匹配这没有什么区别, 但是如果匹配, 两者在结
    果和速度上都会有差别. 为了说明这个不同, 考虑下面的例子(来自Jeffrey Friedl的《精通正则表达式》一书). 使用模式 one(self)?(selfsufficient)?在
    字符串oneselfsufficient 上匹配, PCRE会匹配到oneself, 但是使用POSIX, 结果将是整个字符串 oneselfsufficient. 两个子串都匹配原始字符串, 但是
    POSIX将 最长的最为结果.PCRE可用的修饰符: (i,s,m)

13. 实现PERL正则表达式，
    抓取html文件a标签的所有href超链接正则：
    $is$html = <<aaas退出百度HTML;
    $matches = array();
    preg_match_all ( "/]/is", $html, $matches ); 
    print_r($matches[1]); //输出所有超链接?>

14. 预定义变量、魔术变量、魔术方法比较，及作用举例
    预定义变量（超级全局变量）$GLOBALS,$_SERVER,$_GET,$_POST,$_COOKIE,$_SESSION,$_REQUEST,$_ENV
    魔术方法 __construct 和 __destruct__autoload__get 和 __set__isset 和 __unset__call 
        和 __callStatic__clone__toString__sleep 和 __wakeup__invoke
    魔术变量 __LINE__, __FILE__,__DIR__,__CLASS__,__FUNCTION__,__METHOD__,__NAMESPACE__

15. spl常用数据结构类

16. PHP设计模式工厂模式建立一个工厂（一个函数或一个类方法）来制造新的对象工厂模式 是一种类，它具有为您创建对象的某些方法。您可以使用工厂类创建对象，
    而不直接使用 new。这样，如果您想要更改所创建的对象类型，只需更改该工厂即可。使用该工厂的所有代码会自动更改。单例模式某些应用程序资源是独占的，
    因为有且只有一个此类型的资源。例如，通过数据库句柄到数据库的连接是独占的。您希望在应用程序中共享数据库句柄，因为在保持连接打开或关闭时，它是一
    种开销，在获取单个页面的过程中更是如此。单元素模式可以满足此要求。PHP中的单例模式（singleton pattern）：指的是在PHP的应用程序的范围内只对指定
    的类创建一个实例。在PHP中使用单例模式的类通常拥有一个私有构造函数和一个私有克隆函数，以防 止用户通过创建对象或者克隆对其进行实例化。还有一个静
    态私有成员变量$instance 与静态方法getInstance。getInstance 负责对其本身实例化，然后将这个对象存储在$instance 静态成员变量中，以确保只有一个
    实例被创建。观察者模式命令链模式策略模式

17. 负载均衡的web应用服务器设计，例如youku用PHP做负载均衡指南思考如何应对以下问题。 参考http://www.examw.com/linux/all/142494/在Apache负载均
    衡的情况下，做PHP开发如何考虑一下几方面：PHP源文件在服务器、PHP文件上传处理、相关配置文件、Session会话放置、日志放置Apache负载均衡的原则:
    轮询均衡策略 （轮询转发请求）按权重分配均衡策略 （按响应数量转发请求）
    权重请求响应负载均衡策略 （按响应流量转发请求）

18. 如何优化前端性能1) 页面内容的优化a) 降低请求数合并css、js文件，集成CSS图片b) 减少交互通信量压缩技术：压缩css、js文件，优化图像，
    减少cookie体积；合理利用缓存：使用外部js/css文件，缓存ajax；减少不必要的通信量：剔除无用脚本和样式、推迟加载内容、使用GET请求c) 合理
    利用“并行” 尽量避免重定向慎用Iframe 样式表置于顶部 脚本放到样式后面加载d) 节约系统消耗避免CSS表达式、滤镜2) 服务器的优化a) b)c)d)

19. yahoo的34条前端优化法则减少HTTP请求、利用CDN技术、 设置头文件过期或者静态缓存、Gzip压缩、把CSS放顶部、 把JS放底部、避免CSS 表达
    式、将JS和CSS外链、减少DNS查找、减小JS和CSS的体积、 避免重定向、删除重复脚本、 配置ETags、缓存Ajax、尽早的释放缓冲、用GET方式进行AJAX
    请求、延迟加载组件、 预加载组件、减少DOM元素数量、跨域分离组件、减少iframe数量、不要出现404页面、减小Cookie、 对组件使用无Cookie的域名、
    减少DOM的访问次数、开发灵活的事件处理句柄、使用< link >而非@import、避免过滤器的使用、优化图片、优化CSS Sprites、 不要在HTML中缩放图片、
    缩小favicon. ico的大小并缓存它、保证组件在25K以下、将组件打煲进一个多部分的文档中

20. 数据库缓存的基本理论，参考memcached什么是Memcached。memcached是高性能的分布式内存缓存服务器。一般的使用目的是，通过缓存数据库查
    询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。虽然memcached 使用了同样的“Key=>Value”方式组织数据，但是它和共享内存、
    APC等本地缓存有非常大的区别。Memcached是分布式的，也就是说 它不是本地的。它基于网络连接（当然它也可以使用localhost）方式完成服务，
    本身它是一个独立于应用的程序或守护进程（Daemon方式）PHP与MemcachedMemcached使用libevent库实现网络连接服务，理论上可以处理无限多的连接，
    但是它和18. 如何优化前端性能1) 页面内容的优化a) 降低请求数合并css、js文件，集成CSS图片b) 减少交互通信量压缩技术：压缩css、js文件，
    优化图像，减少cookie体积；合理利用缓存：使用外部js/css文件，缓存ajax；减少不必要的通信量：剔除无用脚本和样式、推迟加载内容、
    使用GET请求c) 合理利用“并行” 尽量避免重定向慎用Iframe 样式表置于顶部 脚本放到样式后面加载d) 节约系统消耗避免CSS表达式、滤镜2)
    服务器的优化a) b)c)d)19. yahoo的34条前端优化法则减少HTTP请求、利用CDN技术、 设置头文件过期或者静态缓存、Gzip压缩、把CSS放顶部、
    把JS放底部、避免CSS 表达式、将JS和CSS外链、减少DNS查找、减小JS和CSS的体积、 避免重定向、删除重复脚本、 配置ETags、缓存Ajax、尽
    早的释放缓冲、用GET方式进行AJAX请求、延迟加载组件、 预加载组件、减少DOM元素数量、跨域分离组件、减少iframe数量、不要出现404页面、
    减小Cookie、 对组件使用无Cookie的域名、减少DOM的访问次数、开发灵活的事件处理句柄、使用< link >而非@import、避免过滤器的使用、
    优化图片、优化CSS Sprites、 不要在HTML中缩放图片、缩小favicon. ico的大小并缓存它、保证组件在25K以下、将组件打煲进一个多部分的文档中
